# Drone Control Software
The UAV control plugin takes UAV positions / velocities / accelerations from Gazebo using the C++ API, computes the difference between UAV position and reference from the FlightPlan, computes the control action and computes the forces and moments to apply to the UAV in Gazebo. Moreover, this plugin also send telemetry data throgh topics with the frecuency selected. 

The plugin implements a SITL (software in the loop) for a lineal model of the UAV through a feedback controller of the state and accumulated error (between the reference to follow and the output) with a set working point so that the UAV remains stably in the air, with zero translation and rotation. The plugin is implemented in C++ language, and the closed loop is executed 1000 times per second, when Gazebo emits the event \textit{ConnectWorldUpdateBegin}. This code could be summarised in 3 stages:

- **Obtaining the position according to the flight plan**: first the location where the aircraft should be at the current time is calculated. This is done using the flight plan abstraction layer, which acts as an intermediate layer between the definition of a flight plan and navigation. This abstraction layer allows to express a flight plan as a continuous function whose input is the time of the simulation, and output is the position in the airspace, instead of using a list of ordered points as are the waypoints. In addition, this layer allows the re-implementation of the flight plan definition without the need to modify the navigation and control of the aircraft.
- **Navigation computation**: with the target position at time $t$ set, navigation computes the difference between the target position and the current aircraft position. The resulting three-dimensional vector will be used as the target aircraft velocity. However, this control will always suffer a delay, always maintaining an error with the reference. To improve the situation, in this work, a linear combination of navigation between t and t+2 seconds has been considered, with a weight of 70% and 30%, respectively. 
- **Actuator control**: finally, the state and accumulated error feedback controller is implemented, which calculates the rotational speed for each of the engines, as if we were dealing with a real aircraft. Subsequently, the speed of the engines is converted to forces that are applied to the model in Gazebo.

You could found the code of the plugin in `utrafman_main` package, in `src` folder. For more details,  [read this paper](https://journals.sagepub.com/doi/10.1177/1729881418820425).