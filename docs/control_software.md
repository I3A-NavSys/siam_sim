# Drone Control Software
The UAV control plugin takes UAV positions/velocities/accelerations from Gazebo using the C++ API, computes the difference between UAV position and reference from the FlightPlan, computes the control action, and computes the forces and moments to apply to the UAV in Gazebo. Moreover, this plugin sends telemetry data through topics with a selected frequency. 

The plugin implements a SITL (software in the loop) for a linear model of the UAV through a feedback controller of the state and accumulated error (between the reference to follow and the output) with a set working point so that the UAV remains stable in the air, with zero translation and rotation. The plugin is implemented in C++, and the closed loop is executed 1000 times per second when Gazebo emits the event \textit{ConnectWorldUpdateBegin}. This code could be summarised in 3 stages:

- **Obtaining the position according to the flight plan**: first, the location where the aircraft should be at the current time is calculated, which is done using the flight plan abstraction layer, and it acts as an intermediate layer between the definition of a flight plan and navigation. This abstraction layer allows the statement of a flight plan as a continuous function whose input is the time of the simulation and output is the position in the airspace, instead of using a list of ordered points, as are the waypoints. In addition, this layer allows the re-implementation of the flight plan definition without needing to modify the aircraft's navigation and control.
- **Navigation computation**: with the target position at time $t$ set, navigation computes the difference between the target and current aircraft positions. The resulting three-dimensional vector will be used as the target aircraft velocity. However, this control will always suffer a delay, always maintaining an error with the reference. To improve the situation, in this work, a linear combination of navigation between t and t+2 seconds has been considered, with a weight of 70% and 30%, respectively. 
- **Actuator control**: finally, the state and accumulated error feedback controller is implemented, which calculates the rotational speed for each engine, as if we were dealing with a real aircraft. Subsequently, the speed of the engines is converted to forces that are applied to the model in Gazebo.

The plugin's code is in the `/utrafman_sim/src/gazebo-ros/src/utrafman/src/dronecontrol.cc` file. For more details,  [read this paper](https://journals.sagepub.com/doi/10.1177/1729881418820425).